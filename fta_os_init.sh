#!/bin/bash

# ==============================================================================
# Script Name: fta_os_init.sh
# Description: This script initializes a CentOS 9 Stream system with common
#              software, security configurations, and performance tuning.
# Author:      FantasticTony (Generated by AI Assistant)
# Version:     1.0
# Date:        06-04-2025
# ==============================================================================

# Source utility functions
UTILS_PATH="$(dirname "$0")/utils.sh"
if [ ! -f "${UTILS_PATH}" ]; then
    echo -e "\033[0;31m[ERROR] utils.sh not found at ${UTILS_PATH}. Please ensure it's in the same directory as this script.\033[0m"
    exit 1
fi
source "${UTILS_PATH}"

# --- Script Start ---
# The msg_info from utils.sh will confirm it's loaded.
msg_info "Starting OS initialization script..."

msg_info "Configuring DNF/YUM..."

# --- System Update ---
msg_info "Performing full system update..."
dnf update -y
check_exit_status "System update failed." "System updated successfully."

# --- DNF/YUM Configuration ---
msg_info "Installing EPEL repository..."
dnf install epel-release -y
check_exit_status "Failed to install EPEL repository." "EPEL repository installed successfully."

# --- Software Installation ---
msg_info "Installing essential software packages..."
dnf install vim screen git wget curl net-tools gcc-c++ make python3-devel NetworkManager-tui -y
check_exit_status "Failed to install essential software." "Essential software installed successfully."
# Note: Changed python-devel to python3-devel for CentOS 9 Stream compatibility.

msg_info "Installing additional useful software..."
dnf install yum-utils device-mapper-persistent-data lvm2 htop telnet -y
check_exit_status "Failed to install additional software." "Additional software installed successfully."

msg_info "Installing Node.js and Yarn..."
curl -fsSL https://rpm.nodesource.com/setup_21.x | bash -
check_exit_status "Failed to setup NodeSource repository." "NodeSource repository setup successfully."
dnf install -y nodejs
check_exit_status "Failed to install Node.js." "Node.js installed successfully."

curl -sL https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo
check_exit_status "Failed to add Yarn repository." "Yarn repository added successfully."
dnf install -y yarn
check_exit_status "Failed to install Yarn." "Yarn installed successfully."

# --- Modern Unix Tools Installation ---
msg_info "Installing modern Unix tools..."

# got (replaces wget) - Note: 'got' might not be a widely known replacement for wget. Included as per original script.
# This tool also seems to be less maintained, the git.io link might be a risk.
# For now, keeping the installation logic but noting potential issues.
msg_info "Installing got..."
TMP_DIR_GOT=$(mktemp -d -p /tmp got_install_XXXXXX)
msg_info "Using temporary directory for got: ${TMP_DIR_GOT}"
( # Start subshell to keep CWD changes local
    cd "${TMP_DIR_GOT}" || exit 1
    curl -sfL https://git.io/getgot | /bin/bash # This script likely creates a bin subdir
    check_exit_status "Failed to download or run getgot script." "getgot script executed."
    if [ -f "bin/got" ]; then
        chmod +x "bin/got"
        mv "bin/got" /usr/local/bin/got
        check_exit_status "Failed to move got to /usr/local/bin." "got installed to /usr/local/bin."
    else
        msg_error "got binary not found in expected location after download."
        # Attempt to find it if it's directly in TMP_DIR_GOT (less likely based on original script)
        if [ -f "got" ]; then
            chmod +x "got"
            mv "got" /usr/local/bin/got
            check_exit_status "Failed to move got to /usr/local/bin." "got installed to /usr/local/bin."
        else
             msg_error "Failed to locate got binary in ${TMP_DIR_GOT} or ${TMP_DIR_GOT}/bin."
        fi
    fi
)
rm -rf "${TMP_DIR_GOT}"
msg_info "Cleaned up temporary directory: ${TMP_DIR_GOT}"

# gtop (system monitoring)
msg_info "Installing gtop..."
yarn global add gtop
check_exit_status "Failed to install gtop." "gtop installed successfully."

# ripgrep (replaces grep)
msg_info "Installing ripgrep (rg)..."
dnf install ripgrep -y
check_exit_status "Failed to install ripgrep." "ripgrep installed successfully."

# bottom (replaces htop)
msg_info "Installing bottom (btm)..."
dnf copr enable atim/bottom -y
check_exit_status "Failed to enable COPR repository for bottom." "COPR repository for bottom enabled."
dnf install bottom -y
check_exit_status "Failed to install bottom." "bottom installed successfully."

# gping (ping with graph)
msg_info "Installing gping..."
dnf copr enable atim/gping -y
check_exit_status "Failed to enable COPR repository for gping." "COPR repository for gping enabled."
dnf install gping -y
check_exit_status "Failed to install gping." "gping installed successfully."

# glances (system monitoring)
msg_info "Installing glances..."
dnf install python3-pip -y # Ensure pip is installed for python3
check_exit_status "Failed to install python3-pip." "python3-pip installed successfully."
pip3 install --user 'glances[action,cloud,cpuinfo,docker,export,folders,gpu,graph,ip,raid,snmp,wifi]'
check_exit_status "Failed to install glances." "glances installed successfully for the current user."
msg_warning "Glances has been installed for the current user (root). If you need it system-wide, consider 'pip3 install glances[...]'"

# dust (replaces du)
msg_info "Installing dust..."
TMP_DIR_DUST=$(mktemp -d -p /tmp dust_install_XXXXXX)
msg_info "Using temporary directory for dust: ${TMP_DIR_DUST}"
(
    cd "${TMP_DIR_DUST}" || exit 1
    curl -L https://github.com/bootandy/dust/releases/download/v1.1.1/dust-v1.1.1-x86_64-unknown-linux-gnu.tar.gz -o dust.tar.gz
    check_exit_status "Failed to download dust." "dust downloaded."
    tar -xvf dust.tar.gz
    check_exit_status "Failed to extract dust.tar.gz." "dust.tar.gz extracted."
    # The extracted folder name is known, but find can be more robust if it changes slightly (e.g. patch version)
    DUST_BINARY=$(find . -name dust -type f -executable -o -name dust) # find executable or just 'dust'
    if [ -n "${DUST_BINARY}" ] && [ -f "${DUST_BINARY}" ]; then
        chmod +x "${DUST_BINARY}"
        mv "${DUST_BINARY}" /usr/local/bin/dust
        check_exit_status "Failed to move dust to /usr/local/bin." "dust installed to /usr/local/bin."
    else
        msg_error "dust binary not found after extraction."
    fi
)
rm -rf "${TMP_DIR_DUST}"
msg_info "Cleaned up temporary directory: ${TMP_DIR_DUST}"

# procs (replaces ps)
msg_info "Installing procs..."
dnf install https://github.com/dalance/procs/releases/download/v0.14.8/procs-0.14.8-1.x86_64.rpm -y
check_exit_status "Failed to install procs." "procs installed successfully."

# curlie (replaces curl)
msg_info "Installing curlie..."
TMP_DIR_CURLIE=$(mktemp -d -p /tmp curlie_install_XXXXXX)
CURLIE_RPM_NAME="curlie_1.7.2_linux_amd64.rpm" # Variable for easier update if version changes
msg_info "Using temporary directory for curlie: ${TMP_DIR_CURLIE}"
(
    cd "${TMP_DIR_CURLIE}" || exit 1
    curl -L "https://github.com/rs/curlie/releases/download/v1.7.2/${CURLIE_RPM_NAME}" -o "${CURLIE_RPM_NAME}"
    check_exit_status "Failed to download curlie RPM." "curlie RPM downloaded."
    dnf install "./${CURLIE_RPM_NAME}" -y
    check_exit_status "Failed to install curlie." "curlie installed successfully."
)
rm -rf "${TMP_DIR_CURLIE}"
msg_info "Cleaned up temporary directory: ${TMP_DIR_CURLIE}"

# duf (replaces df)
msg_info "Installing duf..."
TMP_DIR_DUF=$(mktemp -d -p /tmp duf_install_XXXXXX)
DUF_RPM_NAME="duf_0.8.1_linux_amd64.rpm" # Variable for easier update
msg_info "Using temporary directory for duf: ${TMP_DIR_DUF}"
(
    cd "${TMP_DIR_DUF}" || exit 1
    curl -L "https://github.com/muesli/duf/releases/download/v0.8.1/${DUF_RPM_NAME}" -o "${DUF_RPM_NAME}"
    check_exit_status "Failed to download duf RPM." "duf RPM downloaded."
    dnf install "./${DUF_RPM_NAME}" -y
    check_exit_status "Failed to install duf." "duf installed successfully."
)
rm -rf "${TMP_DIR_DUF}"
msg_info "Cleaned up temporary directory: ${TMP_DIR_DUF}"

# fd (replaces find)
msg_info "Installing fd..."
TMP_DIR_FD=$(mktemp -d -p /tmp fd_install_XXXXXX)
msg_info "Using temporary directory for fd: ${TMP_DIR_FD}"
(
    cd "${TMP_DIR_FD}" || exit 1
    curl -L https://github.com/sharkdp/fd/releases/download/v10.2.0/fd-v10.2.0-x86_64-unknown-linux-gnu.tar.gz -o fd.tar.gz
    check_exit_status "Failed to download fd." "fd downloaded."
    tar -xvf fd.tar.gz
    check_exit_status "Failed to extract fd.tar.gz." "fd.tar.gz extracted."
    # The extracted folder name is known, but find can be more robust
    FD_BINARY=$(find . -name fd -type f -executable -o -name fd)
    if [ -n "${FD_BINARY}" ] && [ -f "${FD_BINARY}" ]; then
        chmod +x "${FD_BINARY}"
        mv "${FD_BINARY}" /usr/local/bin/fd
        check_exit_status "Failed to move fd to /usr/local/bin." "fd installed to /usr/local/bin."
    else
        msg_error "fd binary not found after extraction."
    fi
)
rm -rf "${TMP_DIR_FD}"
msg_info "Cleaned up temporary directory: ${TMP_DIR_FD}"

# --- Alias Configuration ---
msg_info "Configuring aliases for modern Unix tools..."
MODERN_LINUX_SH="/etc/profile.d/modern_linux.sh"
echo "# Modern Linux Tool Aliases" > "${MODERN_LINUX_SH}" # Create or overwrite the file
echo "alias top='glances'" | tee -a "${MODERN_LINUX_SH}"
echo "alias htop='btm'" | tee -a "${MODERN_LINUX_SH}"
echo "alias ps='procs'" | tee -a "${MODERN_LINUX_SH}"
echo "alias du='dust'" | tee -a "${MODERN_LINUX_SH}"
echo "alias df='duf'" | tee -a "${MODERN_LINUX_SH}"
echo "alias find='fd'" | tee -a "${MODERN_LINUX_SH}"
echo "alias grep='rg'" | tee -a "${MODERN_LINUX_SH}"
echo "alias curl='curlie'" | tee -a "${MODERN_LINUX_SH}"
source "${MODERN_LINUX_SH}"
msg_success "Aliases configured in ${MODERN_LINUX_SH}."
msg_warning "You may need to log out and log back in or run 'source ${MODERN_LINUX_SH}' for aliases to take effect in your current session."

# --- SSH Configuration ---
msg_info "Configuring SSH server..."
SSHD_CONFIG="/etc/ssh/sshd_config"
# Add or modify SSH settings. Using sed to avoid duplicate lines if run multiple times.
declare -A ssh_settings
ssh_settings=(
    ["PermitEmptyPasswords"]="no"
    ["UseDNS"]="no"
    ["GSSAPIAuthentication"]="no"
    ["PermitRootLogin"]="prohibit-password" # More secure than 'yes' or 'without-password'
    ["RSAAuthentication"]="yes" # May be deprecated, consider ED25519/ECDSA keys
    ["PubkeyAuthentication"]="yes"
)

for key in "${!ssh_settings[@]}"; do
    value="${ssh_settings[$key]}"
    if grep -q "^${key}" "${SSHD_CONFIG}"; then
        sed -i "s/^${key}.*/${key} ${value}/" "${SSHD_CONFIG}"
        check_exit_status "Failed to update SSH config for ${key}." "SSH config updated for ${key}."
    else
        echo "${key} ${value}" | tee -a "${SSHD_CONFIG}"
        check_exit_status "Failed to add SSH config for ${key}." "SSH config added for ${key}."
    fi
done

systemctl restart sshd
check_exit_status "Failed to restart SSHD service." "SSHD service restarted successfully."
msg_success "SSH server configured."

# --- System Limits Configuration ---
msg_info "Configuring system limits in /etc/security/limits.conf..."
LIMITS_CONF="/etc/security/limits.conf"
# Appending system limits. For true idempotency, one might check if these specific lines
# or similar limits already exist, which is more complex.
# For this refactoring, we'll ensure the lines are added if not present with a simple check.
declare -A limits_settings
limits_settings=(
    ["* soft nofile"]="65536"
    ["* hard nofile"]="65536"
    ["* soft nproc"]="65536"
    ["* hard nproc"]="65536"
)

for key in "${!limits_settings[@]}"; do
    value="${limits_settings[$key]}"
    # Check if the exact line or a line starting with the key (e.g. "* soft nofile") exists
    if grep -q "^${key}" "${LIMITS_CONF}"; then
        msg_info "System limit for '${key}' already likely exists in ${LIMITS_CONF}. Manual check recommended if issues persist."
        # Optionally, one could sed replace it:
        # sed -i "s|^${key}.*|${key} ${value}|" "${LIMITS_CONF}"
    else
        echo "${key} ${value}" | tee -a "${LIMITS_CONF}"
        msg_info "Added system limit: ${key} ${value}"
    fi
done
msg_success "System limits configuration updated."

# --- Kernel Parameters Configuration ---
msg_info "Configuring kernel parameters in /etc/sysctl.conf..."
SYSCTL_CONF="/etc/sysctl.conf"
# Add or modify sysctl settings. Using a helper function for clarity.

apply_sysctl_setting() {
    local key="$1"
    local value="$2"
    msg_info "Applying sysctl setting: $key = $value"
    if grep -q "^\s*${key}\s*=" "${SYSCTL_CONF}"; then
        # Key exists, modify it
        sed -i -E "s/^\s*${key}\s*=.*/${key} = ${value}/" "${SYSCTL_CONF}"
        check_exit_status "Failed to update sysctl setting ${key}." "Sysctl setting ${key} updated."
    else
        # Key does not exist, add it
        echo "${key} = ${value}" >> "${SYSCTL_CONF}"
        check_exit_status "Failed to add sysctl setting ${key}." "Sysctl setting ${key} added."
    fi
}

# Using an associative array for kernel parameters
declare -A sysctl_params
sysctl_params=(
    ["net.ipv4.ip_forward"]="1"
    ["net.core.netdev_max_backlog"]="41960"
    ["net.ipv4.tcp_max_tw_buckets"]="300000"
    ["net.ipv4.tcp_tw_reuse"]="1"
    ["net.ipv6.conf.all.disable_ipv6"]="1"
    ["net.ipv6.conf.default.disable_ipv6"]="1"
    ["net.ipv4.tcp_fastopen"]="3"
    ["net.ipv4.tcp_max_syn_backlog"]="16384"
    ["net.ipv4.tcp_fin_timeout"]="30"
    ["net.core.somaxconn"]="10240"
    ["net.core.default_qdisc"]="fq"
    ["net.ipv4.tcp_congestion_control"]="bbr"
    ["net.ipv4.tcp_mem"]="786432 4194304 8388608"
    ["net.ipv4.tcp_rmem"]="16384 16384 4206592"
    ["net.ipv4.tcp_wmem"]="16384 16384 4206592"
    ["net.core.rmem_default"]="262144"
    ["net.core.wmem_default"]="262144"
    ["net.core.rmem_max"]="16777216"
    ["net.core.wmem_max"]="16777216"
    ["vm.overcommit_memory"]="1"
)

for param in "${!sysctl_params[@]}"; do
    apply_sysctl_setting "${param}" "${sysctl_params[$param]}"
done

# Apply all changes without reboot
sysctl -p
check_exit_status "Failed to apply kernel parameters with 'sysctl -p'." "Kernel parameters applied successfully via 'sysctl -p'."
msg_success "Kernel parameters configured."

# --- SELinux Configuration ---
msg_info "Managing SELinux..."
CURRENT_SELINUX_STATUS=$(sestatus | grep "Current mode:" | awk '{print $3}')
CONFIG_SELINUX_STATUS=$(grep -E "^SELINUX=" /etc/selinux/config | awk -F= '{print $2}')

msg_info "Current SELinux mode: ${CURRENT_SELINUX_STATUS}"
msg_info "SELinux mode in /etc/selinux/config: ${CONFIG_SELINUX_STATUS}"

if [ "${CURRENT_SELINUX_STATUS}" != "permissive" ] && [ "${CURRENT_SELINUX_STATUS}" != "disabled" ]; then
    msg_info "Attempting to set SELinux to Permissive mode for the current session."
    setenforce 0
    check_exit_status "Failed to set SELinux to Permissive." "SELinux set to Permissive for the current session."
else
    msg_info "SELinux is already Permissive or Disabled for the current session."
fi

if [ "${CONFIG_SELINUX_STATUS}" != "disabled" ]; then
    msg_info "Disabling SELinux in /etc/selinux/config..."
    # Attempt to change from enforcing or permissive to disabled
    sed -i -E "s/^(SELINUX=)(enforcing|permissive)/\1disabled/" /etc/selinux/config
    check_exit_status "Failed to disable SELinux in /etc/selinux/config." "SELinux configuration updated to 'disabled'."
    if ! grep -q "^SELINUX=disabled" /etc/selinux/config; then
        # If the line didn't exist or wasn't enforcing/permissive, add it.
        msg_warning "SELINUX line not found or not in expected state, adding SELINUX=disabled."
        echo "SELINUX=disabled" >> /etc/selinux/config
        check_exit_status "Failed to add SELINUX=disabled to /etc/selinux/config." "SELINUX=disabled added to /etc/selinux/config."
    fi
    msg_warning "A reboot is required for SELinux changes in /etc/selinux/config to take full effect."
else
    msg_info "SELinux is already set to 'disabled' in /etc/selinux/config."
fi

# --- Cleanup ---
msg_info "Cleaning up temporary files..."
rm -rf /tmp/*
msg_success "Temporary files cleaned up."

# --- Final Message ---
msg_success "===== ALL DONE, SYSTEM INITIALIZED! ====="
msg_info "Consider the following optional step: systemctl stop firewalld && systemctl disable firewalld"
msg_warning "Please reboot the system for all changes to take full effect (especially SELinux and kernel parameters)."

exit 0
